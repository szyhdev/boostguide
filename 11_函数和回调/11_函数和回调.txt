第十一章 函数和回调

一、ref
  1、类摘要
  2、基本用法
  3、工厂函数
  4、操作包装
  5、综合应用
  6、对比标准
二、bind
  1、工作原理
  2、操作普通函数
  3、操作成员函数
  4、操作成员变量
  5、操作函数对象
  6、对比标准
  7、高级议题
    1）为占位符更名
    2）存储bind表达式
    3）使用ref库
    4）嵌套绑定
    5）操作符重载
    6）绑定重载函数
    7）绑定非标准函数
三、function
  1、类摘要
  2、声明形式
  3、操作函数
  4、用法
  5、用ref库
  6、用于回调
  7、对比标准
四、signals2
  1、类摘要
  2、操作函数
  3、用法
    1）基本用法
    2）使用组号
  4、返回值
  5、合并器
  6、管理信号连接
  7、更灵活地管理信号连接
  8、自动管理连接
  9、应用于观察者模式
  10、高级议题
    1）让signal支持拷贝
    2）插槽调度
    3）线程安全
    4）让插槽自己管理连接
    5）对比function
    6）扩展实现operator ==
五、小结

- 本章的讨论主题主要围绕函数和函数对象，涉及四个库，它们是Boost库中较为复杂的组件，应用了C++中的高级语言特性和技巧，其中，前三个已被收入C++11标准
- ref是其他几个库的基础，使用它可以包装对象的引用，可以在传递参数时消除对象拷贝的代价，还可以将不可拷贝的对象变为可拷贝的
- bind是对C++标准程序库的函数适配器的增强，可以适配任意可调用的对象，包括函数指针、函数引用和函数对象，把它们变为一个新的函数对象
- function是对C/C++中函数指针的增强，可以容纳任意的可调用对象，并且可以配合bind来使用
- signals2实现了强大的观察者模式，类似于Java中的Observable/Observer或C#中的event/delegate

一、ref

- C++标准库和Boost库中的算法大量使用了函数对象作为判断式或谓词参数，这些参数都是按值传递的，算法或函数会在内部保留函数对象的拷贝来使用
- 一般情况下，按值传递是可行的，但有时候作为参数的函数对象的拷贝代价过高（具有复杂的内部状态），或者不希望拷贝对象（内部状态不应该改变），甚至拷贝是不可行的（不可复制的或者单件的）
- ref通过代理模式引入了对象引用的包装器，它位于名字空间boost，需要包含头文件<boost/ref.hpp>

1、类摘要

- ref库定义了一个很小的、很简单的引用类型的包装器，reference_wrapper
  * reference_wrapper的构造函数接受一个类型T的引用，并在内部保存指向它的指针，该构造函数被声明为explicit，因此，在创建对象时必须进行初始化，就像在使用一个引用类型的变量一样
  * 成员函数get和get_pointer分别返回存储在内部的引用和指针，相当于解开了对引用类型的包装
- reference_wrapper还支持隐式类型转换，可以自动转换为内部存储的引用，因此，能够被用在需要类型T出现的地方

2、基本用法

- 使用reference_wrapper类似于C++中的引用类型T&，不过，它只有在需要T的语境中才会进行隐式转换，其他情况下必须调用类型转换函数或者get成员函数才能操作被包装的对象
- 此外，reference_wrapper还支持拷贝构造和赋值，而引用类型是不可赋值的

- 注意，最后一行代码中的cout语句并不存在一个string类型的隐式转换，因此，必须调用get来获得被包装的对象，再调用它的方法size以获得字符串的长度
- 因此，reference_wrapper是个很像引用的对象，但它和引用类型无论在用法上还是用途上都存在差异

3、工厂函数

- reference_wrapper名字过长，使用它声明包装对象不太方便，因此，ref库提供了两个便捷的工厂函数，ref和cref，它们可以通过推导参数类型来构造包装对象
- ref构造的类型是T，而cref构造的类型是const T
- 由于reference_wrapper支持拷贝，因此，ref和cref可以直接用于需要拷贝语义的函数参数中，而不必专门使用一个reference_wrapper变量来暂存

4、操作包装

- ref库提供了两个类，is_reference_wrapper和unwrap_reference，来检测包装对象
  * is_reference_wrapper<T>::value用来判断T是否已被包装
  * unwrap_reference<T>::type返回T的真实类型，不管它是否已被包装

- 自由函数unwrap_ref为解开包装提供了更简便的方法，它利用unwrap_reference直接解开包装对象，返回被包装对象的引用
  * 对一个未包装的对象使用unwrap_ref也是允许的，它直接返回该对象的引用
  * unwrap_ref可以安全地用于泛型代码中，不必关心对象是否被包装，因为它总是能够正确地操作对象

5、综合应用

- 假设big_class具有复杂的内部状态，对它进行构造和拷贝都具有很高的代价
- 模板函数print接受任意类型的参数，针对该类型参数调用其print成员函数，考虑到该参数可能已被包装，因此对它使用了unwrap_ref
  * 调用print(c)时，由于参数是按值传递，因此，内部状态的变化不影响原来的对象
  * 调用print(rw)时，虽然参数仍然是按值传递，但传递的是reference_wrapper对象，它被解开为对原对象的引用，因此，原对象的内部状态会被改变

6、对比标准

- ref库将对象包装为引用语义，使引用的行为更像对象，可以被容器安全地持有，因此被称为“智能引用”，并收入了C++11标准
- C++11标准中的reference_wrapper是由Boost的ref库演变而来的，所以它们非常相似，但也有少许不同，最大的区别是，std::reference_wrapper支持operator ()，因此，可以用来包装一个函数对象的引用并将其传递给标准库中的算法

二、bind

- bind是对C++标准库中的函数适配器bind1st/bind2nd的泛化和增强，可以适配任意可调用的对象，包括函数指针、函数引用、成员函数指针、函数对象和lambda表达式
- bind最多可以绑定9个参数，而且它对被绑定的对象的要求很低，可以在没有result_type内部类型定义的情况下完成对函数对象的绑定
- bind位于名字空间boost，需要包含头文件<boost/bind.hpp>

1、工作原理

- bind并不是一个单独的类或函数
  * 根据绑定的参数个数和要绑定的对象的类型的不同，它有数十个不同的重载形式
  * 编译器会根据具体的绑定代码推导出应该使用的正确形式
- bind接受的第一个参数必须是一个可调用对象，可以是函数、函数指针、函数对象、成员函数指针等，随后可以绑定最多9个参数，参数的数量必须与可调用对象的参数数量相等
- 绑定完成后，bind返回一个函数对象，它的内部保存了可调用对象及其参数
  * 它具有operator ()，返回值类型被自动推导为可调用对象的返回值类型
  * 在函数调用发生时，它把保存的参数传递给保存的可调用对象来完成调用

- 使用bind的最简单形式为bind(func, a1, a2)()，它会把a1和a2作为参数传递给func以完成调用
- bind的真正威力在于它的占位符
  * 这些占位符被定义为_1、_2直到_9，用来取代bind中参数的位置
  * 注意，只有在发生函数调用时才接收真正的参数
- 占位符的名字以下划线开始，然后接一个数字，它们的名字表示在调用中的顺序，不表示在绑定表达式中的顺序，比如，_1不一定第一个出现，也不一定只出现一次

2、操作普通函数

- bind可以通过函数或函数指针来绑定普通函数
- 通过使用占位符，bind可以有更多的变化，这才是它的价值所在
  * 在绑定表达式中，必须提供函数要求的所有参数，不管是真实参数还是占位符都可以
  * 占位符可以出现，也可以不出现，出现的顺序和数量也没有限制，但不能使用超过函数参数数量的占位符

- bind可以替代C++标准库中的bind1st和bind2nd
  * bind1st(f, N)(x)把第一个参数用固定值代替，相当于bind(f, N, _1)(x)，即，f(N, x)
  * bind2nd(f, N)(x)把第二个参数用固定值代替，相当于bind(f, _1，N)(x)，即，f(x, N)
- bind也可以绑定函数指针，用法相同

3、操作成员函数

- 类的成员函数不同于普通函数，它不能直接调用，必须先被绑定在一个对象或指针上，然后通过该对象或指针进行调用
  * 因此，bind需要牺牲一个占位符的位置来要求用户提供对象、对象引用或者对象指针
  * 这也意味着使用成员函数时，bind只能绑定最多8个参数
- 注意，在绑定成员函数时，必须在成员函数前面加上取址操作符&，以表明使用的是一个成员函数指针，这是和绑定普通函数不同的地方

- bind支持绑定成员函数，这个功能可以替代C++标准库中令人迷惑的mem_fun和mem_fun_ref绑定器，以配合标准算法来操作容器中的对象
- bind还支持虚拟成员函数，用法相同，虚拟成员函数的行为由实际调用时的对象来决定

- 示例程序展示了bind绑定成员函数的用法
  * 不管是类的对象，还是对象的引用，或者对象指针，bind都是可以工作的
  * bind也可以配合标准算法来操作容器中的对象

4、操作成员变量

- bind的另一个针对类的操作是，绑定成员变量，用法与绑定成员函类似，只需要把成员函数替换为成员变量即可
- 因此，bind可以替代SGISTL/STLport中的非标准函数适配器select1st和select2nd，直接访问pair对象的first和second成员，当然，bind比它们更强大，因为bind可以访问任意名字的成员变量

5、操作函数对象

- bind还可以绑定函数对象，包括C++标准库中所有的预定义的函数对象
  * 如果函数对象内部有result_type类型定义，bind可以推导出返回值类型
  * 否则，需要在绑定时通过模板参数指明返回值类型

- C++标准库和Boost库中的大多数函数对象都具有result_type定义，因此，可以不通过模板参数直接使用bind
- 对于自定义函数对象，如果没有result_type类型定义，只需要在模板参数中指明返回值类型即可
- 如果觉得这样做多少有些不便，最好还是遵循规范增加内部的result_type类型定义，这样，该函数对象就可以与C++标准库和Boost库中的组件更好地配合工作

6、对比标准

- C++11标准使用可变参数模板和完美转发简化了bind的定义，可以绑定任意数量的参数
- std::bind的用法和boost::bind的完全相同，但为了避免冲突，C++标准中的占位符被定义在std::placeholders名字空间，略显不便
- C++11标准还提供了lambda函数，可以声明匿名函数对象，用法很灵活
  * lambda函数在某种程度上可以替代bind，捕捉列表相当于绑定变量，函数参数列表则相当于bind的占位符
  * 二者相比较，lambda函数更容易理解一些

7、高级议题

1）为占位符更名

- bind库默认使用了_1、_2等作为占位符的名称，通常这可以清晰地表明被调用参数的含义
- 如果想使用更好懂、更易记的名字，bind库允许为这些占位符创建别名，这是通过boost::arg来完成的
- 为占位符创建别名也可以通过auto或decltype来完成，这样就不需要关心占位符的真实类型了
- 占位符的别名的用法和占位符完全相同

2）存储bind表达式

- 有时候，需要将bind表达式存储起来稍后再使用，这时使用auto可以简化对bind表达式所生成的函数对象的类型声明
- 后面介绍的function也可以达到同样的目的，但它的功能更强大

3）使用ref库

- bind采用拷贝的方式存储函数对象和参数，这意味着绑定表达式中的每个变量都会有一份拷贝，如果函数对象或参数很大，拷贝的代价也会很高
- 和ref库配合使用，可以让bind存储对象引用的拷贝，从而降低拷贝的代价，不过，程序员必须保证bind表达式所生成的函数对象在其被调用时是有效的

4）嵌套绑定

- bind可以嵌套使用，即，一个bind表达式生成的函数对象可以被另一个bind再次绑定，从而实现出类似f(g())这样的形式
- 使用嵌套绑定时需要多加小心，它不太容易一次写正确，也不太容易理解，最好是添加必要的注释以说明其含义

5）操作符重载

- bind表达式生成的函数对象重载了比较操作符和逻辑非操作符，因此，可以把多个bind表达式组合起来，形成一个复杂的逻辑表达式，进而可以配合标准库算法实现语法简单但语义复杂的操作
- 上述方法很好用，但不熟悉bind语法的读者很难理解，所以应该慎用、少用
- 更多的情况下可以使用lambda函数来就地定义出复杂的逻辑表达式

6）绑定重载函数

- 直接绑定函数名的方式有一点局限，如果存在多个重名的重载函数，bind就无法确定要绑定的具体函数
- 一个解决方法是，为其分别定义函数指针类型，再使用函数指针变量来确定要绑定的函数
- 不过，上述方法对于模板函数是无效的，因为很难写出一个准确的模板函数指针类型，此时可以使用lambda来变通地进行绑定

7）绑定非标准函数

- bind库大大增强了C++标准库中的函数绑定器，可以适配任何C++中的函数
- 但标准形式的bind不能适用于所有的情况，有些非标准函数是无法自动推导出返回值类型的，比如，printf，这是必须通过模板参数来指明返回值类型

- bind的标准形式也不能支持使用了不同的调用方式的函数，比如，__stdcall、__fastcall、extern "C"等，这时也需要显式地指明返回值类型才能正常绑定
- 通过在包含<boost/bind.hpp>头文件之前定义BOOST_BIND_ENABLE_STDCALL、BOOST_BIND_ENABLE_FASTCALL等宏，可以明确地告诉bind支持这些调用方式

三、function

- function是一个函数对象的“容器”
  * 在概念上，它是C++函数指针类型的泛化，是一种智能函数指针
  * 它以对象的形式封装了原始的函数指针或函数对象，能够容纳任何符合函数签名的可调用对象
  * 因此，它可以被用于回调机制，暂时保管函数指针或函数对象，使得回调机制更富有弹性
- function可以配合bind或lambda函数使用，存储bind或lambda表达式的结果，这样就可以多次调用了
- function位于名字空间boost，需要包含头文件<boost/function.hpp>

1、类摘要

- 和bind一样，function也不是一个单独的类，而是一组类
  * function可以容纳0到10个参数的函数，其类名从function0到function10
  * 不过，通常不会直接使用它们，而是使用一个更通用的function类

2、声明形式

- 使用function只需要提供一个模板参数，该参数指明要容纳的函数的类型
- 该模板参数本身可以不带参数名，也可以像真实的函数那样带有参数名
- 如果已经知道了要容纳的函数，也可以通过decltype来推导出函数的类型，注意，要使用decltype(f)而不是decltype(&f)，后者会推导出函数指针类型而不是函数类型

3、操作函数

- function的构造函数可以接受任意符合模板参数中声明的函数类型的可调用对象，可以是函数指针、函数对象或者另一个function对象的引用，然后在类内部存储一份它的拷贝
  * 无参的构造函数或者传入空指针的构造函数将创建一个空的function对象，不持有任何可调用物，调用该对象将导致一个异常
  * 因此，在使用一个function对象之前应该检查它的有效性，可以通过empty成员函数或者operator !来判断一个fucntion对象是否为空，一个function对象也可以直接用于bool语境中来测试是否为空

- function 的其他成员函数
  * clear成员函数用来将function对象置空
  * target成员函数返回function对象内部持有的可调用物
  * contains成员函数用来检查function对象是否持有某个可调用物
  * operator ()用来完成函数调用

- function还重载了operator ==和operator !=，用来与被包装的函数指针或函数对象进行比较
  * 如果被包装的是函数指针，比较操作相当于function.target<functor>() == func_pointer
  * 如果被包装的是函数对象，函数对象必须实现了operator ==才是可比较的
- 注意，两个function对象是不能比较的
  * function存在bool语境的隐式转换，但这种转换是用来判断function对象是否为空的
  * function声明了operator ==，但没有实现，试图比较两个function对象会导致编译错误

4、用法

- function可以被想象为一个泛化的函数指针，任何符合声明中的函数类型的函数、成员函数、函数对象都可以存储在function对象中，并在需要时被调用
- 与函数指针相比，function对象的体积稍大（3个指针的大小），速度也稍慢（10%左右的性能差距），但这些缺点和它带来的巨大好处相比显得微不足道
- 只要函数签名一致，function也可以存储成员函数和函数对象，还可以存储bind或lambda表达式
  * 存储成员函数时，可以在function声明的函数签名中指定类的类型，然后在bind中绑定成员函数
  * 另一种方法是，在function声明中仅指明成员函数的签名，然后在bind中绑定类的实例

5、使用ref库

- function使用拷贝语义保存参数，当参数较大时，拷贝的代价往往很高，甚至无法拷贝
- 这时，可以使用ref来帮忙，它允许以引用的方式传递参数，降低拷贝的代价

- function不要求ref提供operator ()，它可以自动识别包装类reference_wrapper，并调用成员函数get来获得被包装的对象，这弥补了Boost的ref没有operator ()的遗憾
- 所以，尽管Boost的ref由于没有提供operator ()而无法直接被用于C++标准库算法，但经过function包装以后，问题就解决了

6、用于回调

- function可以容纳任意符合函数签名的可调用对象，因此，它可以代替函数指针来存储回调函数，使代码更灵活
- 定义一个类demo_class，它使用function代替函数指针来保存回调函数，回调函数的签名为void(int)
  * 成员模板函数accept用来接收回调函数，使用模板函数可以使用户传递任意的可调用对象，包括函数指针、函数对象等
  * 成员函数run用来调用回调函数
  * call_back_func是一个用于回调的函数，而call_back_obj则是一个用于回调的函数对象，它们都可以作为可调用对象被保存到demo_class中

- function还可以搭配bind使用来接收类成员函数，或者把不符合函数签名的函数通过bind转换为可接受的形式
- function用于回调的好处是，不需要改变回调的接口就可以支持多种回调形式，并持续演化，解耦了客户代码，使客户代码不必绑定在某一种回调形式上

7、对比标准

- 有时候可以用auto取代function
  * 但auto只是一个在编译时期推导出来的类型，很难再给它赋予其他值，也无法容纳其他类型，不能用于泛型编程
  * function则类似一个容器，可以容纳任何实现了operator ()的可调用对象，包括函数指针、函数对象、lambda表达式等，它是运行时的，可以拷贝和赋值
- 如果需要存储一个可调用对象用于回调，最好使用function，它具有更强的灵活性，尤其是在把回调形式保存在一个类的成员中时
- auto只是在性能上比function略高一点儿，因为它的类型是在编译期推导出来的，没有运行时的开销，但其灵活性很差，只能用于有限范围内的延时回调

- C++11定义了std::function，它和boost::function基本相同
- 和boost::function相比，std::function只有少量的差别
  * 没有成员函数clear和empty
  * 额外提供了成员函数assign
  * 使用bool类型转换符必须是显式进行的
- 因此，std::function在函数返回值或者函数参数等语境中进行bool类型转换时，需要使用static_cast<bool>(f)或者!!f的形式

四、signals2

- signals2衍生自Boost中一个已经废弃的库，signals，它实现了线程安全的观察者模式
  * 在signals2中，观察者模式被称为“信号/插槽”，这是一种函数回调机制
  * 一个信号关联了多个插槽，当收到信号时，所有与它关联的插槽都会被调用
- 很多成熟的软件系统都会用到这一机制，它的另一个常用名称是“事件/事件处理函数”，可以很好地解耦一组相互协作的类，有的语言甚至内建了对该功能的支持
- signals2以库的形式为C++增加了这个重要功能
- signals2位于名字空间boost::signals2，需要包含头文件<boost/signals2.hpp>

1、类摘要

- signals2的核心类是signal，相当于C#中的event和delegate
- signal的模板参数列表很长，总共有七个参数，这里列出比较重要的四个，除了第一个是必须的之外，其他的都可以使用默认值
  * Signature：和function的含义相同，表示一个可以被signal调用的函数（即，插槽）
  * Combiner：这是一个被称为“合并器”的函数对象，用来组合所有插槽的调用结果，默认情况下返回最后一个被调用的插槽的返回值
  * Group：插槽编组的类型，默认使用int来标记组号，也可以改为其他类型，比如string，但通常没必要
  * GroupCompare：与Group配合使用来确定插槽编组的顺序，默认是升序，即，less<Group>，这要求Group必须支持operator <

- signal派生自signal_base，后者派生自noncopyable，因此，signal是不可拷贝的
- 如果一个自定义类包含signal类型的成员变量，则该类也是不可拷贝的，除非使用shared_ptr或ref间接地持有它

2、操作函数

- signal最重要的操作函数是插槽管理函数connect，它把插槽连接到信号上，相当于为信号增加了一个处理函数
  * 插槽可以是任意的可调用对象，包括函数指针、函数对象、bind表达式、lambda表达式、function对象等
  * signal内部使用function作为容器来保存这些可调用对象
  * 连接时可以指定组号，也可以不指定组号，当信号发生时，将按照组号的顺序依次调用插槽函数
  * 如果连接成功，connect会返回一个connection对象，用来管理连接
- 成员函数disconnect用来断开插槽和信号之间的连接，它有两种形式，传递组号将断开该组的所有插槽，传递一个插槽对象将仅断开该插槽，而disconnect_all_slots用来一次性断开信号的所有插槽连接
- 成员函数num_slots返回当前信号所连接的插槽数量，而empty用来判断num_slots是否为0
- signal提供了operator ()，它最多可以接受9个参数，当该操作符被外界调用时，意味着产生了一个信号，进而导致与该信号关联的所有插槽被调用，调用插槽的结果被合并器处理后返回，默认情况下是一个optional对象
- 成员函数combiner和set_combiner分别用来获取和设置合并器对象，合并器对象也可以通过构造函数传入，但通常可以直接使用模板参数列表中指定的合并器对象
- 当signal析构时，将自动断开所有的插槽连接，相当于调用了disconnect_all_slots

3、用法

- signal就像一个增强的function对象，可以容纳多个符合函数签名类型的插槽，形成一个插槽链表，在信号发生时这些插槽都会被调用

1）基本用法

- connect的第二个参数的默认值是at_back，表示将插槽插入到插槽链表的尾部
- 为第二个参数使用at_front则会将插槽插入到插槽链表的头部

2）使用组号

- connect函数的另一个形式可以在连接时指定插槽所在的组号，默认情况下组号为int
- 组号不一定是一个从0开始的连续编号，它可以是任意值，离散值或者负值都是允许的
- 指定了组号后，每个编组的插槽又形成一个插槽链表，结果形成了一个二维插槽链表，它的顺序规则如下
  * 各个编组的调用顺序按组号从小到大确定，当然，也可以通过signal的第四个模板参数来改变排序规则
  * 每个编组的插槽链表内部按照插入时指定的顺序确定
  * 如果未被编组的插槽的位置标志是at_front，则它会在所有的编组之前被调用
  * 如果未被编组的插槽的位置标志是at_back，则它会在所有的编组之后被调用

4、返回值

- 和function一样，signal不仅可以将参数转发给插槽，也可以传回插槽的返回值
- 默认情况下，signal使用合并器optional_last_value<R>，它将返回最后被调用的插槽的返回值
- 由于signal返回的是一个optional对象，所以必须使用解引用操作符*来获得其中的值

5、合并器

- 默认的合并器optional_last_value<R>并没有太大意义，它通常用在不需要关心返回值或者返回值为void的时候
- 但很多情况下，插槽的返回值是有意义的，需要以某种方式对它们进行处理

- signal允许用户自定义合并器来处理插槽的返回值，并把多个插槽的返回值合并为一个结果返回给用户
- 合并器应该是一个函数对象，而不是一个函数或函数指针，它的operator ()的返回值可以是任意类型，完全由用户指定，其模板参数InputIterator是插槽链表的返回值迭代器，用来遍历所有插槽的返回值，以便进行必要的处理
- 使用自定义的合并器时，在signal的第二个模板参数中指明合并器的类型
  * 如果没有为signal的构造函数提供合并器的实例，signal的构造函数会按照第二个模板参数指明的类型默认构造出一个实例
  * 否则，signal的构造函数将使用该实例的拷贝来处理返回值

6、管理信号连接

- 信号和插槽之间的连接并不是永久性的，当信号调用完插槽后，可以把插槽从信号上断开，再连接到其他信号上
  * 成员函数disconnect用来断开一个或一组插槽
  * 成员函数disconnect_all_slots用来断开所有的插槽
  * 成员函数num_slots和empty用来检查当前插槽的连接状态
- 要断开一个指定的插槽，插槽必须能够进行等价比较，对于函数对象来说，这相当于重载一个operator ==

- 使用signal管理插槽有一点不方便，因为它必须知道所有插槽的信息，还要求插槽是可以进行等价比较的
- 但很多时候这些条件很难都满足，比如，插槽是由其他库提供的或者插槽不支持等价比较操作

7、更灵活地管理信号连接

- 因此，signal还提供了另外一种较为灵活的连接管理方式，使用connection对象
  * 每当signal使用connect连接插槽时，就会返回一个connection对象，它就像是一个信号和插槽之间连接的句柄，通过这个句柄就可以管理连接
  * connection对象是可拷贝的、可赋值的，它也重载了比较操作符，可以被安全地放入标准容器中
  * 它的成员函数disconnect和connected分别用来断开连接和检查连接的状态

- 另一种连接管理对象是scoped_connection，它是connection的子类，提供类似scoped_ptr的功能，即，信号和插槽的连接仅在作用域内有效，当离开作用域时就会自动断开
- 当需要临时连接时，scoped_connection会非常有用

- 信号和插槽的连接一旦断开就不会再连接起来，connection不提供reconnect这样的函数
- 但connection可以暂时阻塞信号和插槽的连接，当信号发生时，被阻塞的插槽不会被调用
- connection的blocked函数用来检查插槽是否被阻塞，被阻塞的插槽并没有与信号断开连接，在需要时可以随时解除阻塞
- connection本身没有阻塞的功能，辅助类shared_connection_block用来实现阻塞，直到它的析构函数被调用或者显式调用成员函数unblock

8、自动管理连接

- 如果信号和插槽建立连接后，插槽被意外地销毁了，此时如果信号发生了，将引起未定义的行为
  * 示例代码很短，销毁插槽指针引起的未定义行为不一定会导致程序崩溃，因为插槽指针指向的内存还没有被其他操作覆盖
  * 在一个大型程序中，在插槽指针失效后调用信号的后果不堪设想

- 为了避免未定义行为的发生，signals2库使用slot类提供了自动管理连接的功能，可以自动跟踪插槽的生命周期，在插槽失效时自动断开连接，以保证程序不会出现运行时错误
- 虽然slot用来自动管理插槽的连接，但通常不会直接使用它，而是使用signal内部的slot_type，它已经定义好了signal使用的slot的模板参数

- 使用自动管理连接的功能时，不能直接使用插槽，而是先用slot的构造函数包装插槽，再用成员函数track来跟踪插槽使用的资源
- 注意，track不支持C++标准的std::weak_ptr，因此只能使用Boost的weak_ptr

- slot的构造函数支持与bind表达式相同的语法，这样就可以就地绑定函数，没有使用bind表达式的构造成本
- 注意，在使用bind时必须为其传递slot原始指针，否则，slot会持有一个shared_ptr的拷贝，导致引用计数增加，影响shared_ptr的管理

9、应用于观察者模式

- 本节将使用signals2开发一个完整的观察者模式的示例程序，该程序会模拟一个日常生活中的场景，访客按门铃后，护士醒来开门或者继续睡觉，婴儿醒来啼哭或者继续睡觉
  * 类ring是本程序的核心类，它拥有一个signal_t对象alarm，成员函数press用来模拟按门铃的操作，当该函数被调用时alarm被调用
  * 全局变量g_rand使用Boost的random库来产生随机数
  * 类nurse有一个成员函数action，它根据随机数决定是醒来开门还是继续睡觉，由于它的模板参数使用了const char*，因此，实例化时必须将字符串声明为extern
  * 类baby的实现和类nurse类似
  * 类guest的唯一成员函数是press，它模拟了按门铃的动作

10、高级议题

1）让signal支持拷贝

- signal是noncopyable的派生类，因此，它不能被拷贝或赋值，如果自定义类有signal成员变量，那么该自定义类也不能被拷贝
- 如果出于某种原因，需要在多个对象之间共享signal对象，可以考虑使用shared_ptr<signal>作为类的成员，这可以很好地管理signal的共享语义

2）插槽调度

- 因为signal会自动把解引用操作转换为插槽调用，所以，自定义合并器在某种程度上相当于一个插槽调度器
- 程序可以不要求所有的插槽都被调用，而是只调用那些符合特定条件的插槽，比如，当一个插槽的返回值满足要求后就终止迭代，不再调用其他的插槽

3）线程安全

- signal模板参数列表的最后一个参数是互斥量，默认值为signals2::mutex，它会自动检测编译器的线程支持程度以决定要使用的互斥量对象，通常，这个默认值就工作得很好，不需要改变它
  * signal对象在创建时会自动创建一个mutex来保护内部状态，每个插槽连接时也会创建一个新的mutex
  * 这样，当信号和插槽被调用时，mutex就会自动锁定，使signal可以很好地工作在多线程环境中
- 同样地，connection/shared_connection_block也是线程安全的，但用于自动连接管理的slot不是线程安全的
- signals2库中还有一个dummy_mutex，它是一个空的mutex类，使用它可以把signals2变成非线程安全的版本，这样做是因为不使用锁定可以使速度稍微快一点儿
- 要指定最后一个互斥量参数，需要指定前面的默认参数的类型，signals2通过模板元函数来简化这个工作

4）让插槽自己管理连接

- 默认情况下，插槽和信号signal、连接connection都是无关的，它无法处理与信号的连接，只能由连接时返回的connection对象来处理
- signals2库提供了connect_extended和extended_slot_type来让插槽接收一个额外的connection对象来自己管理连接
- 为了这个功能，需要修改插槽的声明，使它能够接收connection对象
- 为此，在连接插槽时，必须使用extended_slot_type的类似bind的语法，通过占位符_1向插槽传递connection对象

5）对比function

- signal内部使用function来存储可调用对象，它的声明也和function很像，提供了operator ()
- 当signal只连接了一个插槽时，它基本上和function等价
- 需要注意的是，function直接返回被包装的函数的返回值，而signal返回optional对象，必须通过解引用操作符才能获得真正的返回值
- signal用于回调的灵活性比function更好，但这也使得signal的用法比较复杂，更难掌握

6）扩展实现operator ==

- signal不支持operator +=，如果需要，可以自己添加这个功能
- 示例程序中的operator +=直接调用connect函数来实现，二者是等价的
- 为了支持任意数量的参数的operator ()调用，这里使用了可变模板参数和完美转发

五、小结

- 本章讨论了Boost中的四个用于函数和回调的组件，使用它们需要对C++的许多高级特性有深刻的理解
- ref能够包装对象的引用，使之成为一个可以被拷贝和赋值的普通对象，从而减少了昂贵的复制代价
  * ref最初是tuple库的一部分，后来由于其重要性被移出来成为单独的组件
  * 标准算法、tuple、bind、function等许多库都受益于它
- Boost的ref有一个缺陷，它不支持operator ()，因此，应该尽可能使用C++标准的std::ref
- bind是一个功能强大的函数绑定器，它超越了历史上出现过的各种函数绑定器，比如，标准库中的bind1st、bind2nd、mem_fun和非标准库中的select1st、select2nd、compose_f_gx等
  * bind可以绑定任意可调用的对象，和算法配合可以实现各种灵活强大的功能
  * bind还支持嵌套和操作符重载，利用这一点可以实现具有丰富表达力的表达式
- bind的缺点是过于复杂的bind表达式会导致代码不容易读懂，一般来说，在一个绑定表达式中使用两个以上的bind并不是一个好办法，替代的方案是使用lambda表达式
- function是对函数指针的泛化，它可以存储任意可调用的对象，比函数指针更灵活
  * 它可以配合bind使用，存储bind表达式以备之后使用
  * 它也可以配合ref使用，存储带有内部状态的函数对象，并弥补Boost的ref没有operator ()的缺陷
- signals2综合运用了前三个组件，使用信号/插槽机制，实现了观察者模式，简化对象之间的通信关系，降低它们的耦合性
- signals2还有一些高级用法，可以使用合并器来任意处理插槽的返回值，可以自动跟踪插槽的生命周期，同时，它是线程安全的，可以被用在多线程环境中

<2022-12-6>
